            <!DOCTYPE html>
            <html lang="ru">
                <head>
                    <meta charset="utf-8">
                    <TITLE>An application with a long head</TITLE>
                    <link rel="stylesheet" href="csstest.css"> 
                    </head>
                    <body>
                    <header>
                        <div class = "title"><h1>Проект для Onix </h1></div>          
                    </header>
                    <div class='ol'>
      <h2 style="text-align: center;"> Материал по теме проекта:</h2>
      <ol>
      <li>Что такое система контроля версий и зачем она нужна</li>
       <li>checkout, add, commit, pull, push</li>
       <li>Основы ветвления и слияния</li>
        <li>что такое nodejs, зачем он нужен и как устанавливать</li>
         <li>Что такое менеджер пакетов, установка npm</li>
          <li>Html: теги, структура html страницы, блочные и строчные элементы, списки, таблицы, атрибуты, текст, якоря, ссылки, w3c валидация</li>
           <li>Css: стили, классы, идентификаторы, селекторы, псевдоклассы, псевдоэлементы</li>
                  </ol>
                </div>   

                <div class='p'>                                                       
      <p><strong>Система контроля версий</strong> — это система (git), записывающая изменения в файл, набор файлов, в течение времени, позволяющая вернуться позже к определённой версии. 
     хотя на самом деле вы можете использовать контроль версий практически для любых типов файлов.</p>

      <p><strong>Локальные системы контроля версий</strong></p>

      <p>Многие люди в качестве метода контроля версий применяют копирование файлов в отдельную директорию (возможно в, директорию с отметкой по времени). 
      Данный подход очень распространён из-за его простоты, однако он невероятно сильно подвержен появлению ошибок, можно легко забыть, в какой директории вы находитесь, 
      и случайно изменить не тот файл или скопировать не те файлы, которые вы хотели.</p>
      <p>Для того, чтобы решить эту проблему, программисты давным-давно разработали локальные СКВ с простой базой данных, которая хранит записи о всех изменениях в файлах, осуществляя тем самым контроль ревизий.
      Одной из популярных СКВ была система RCS, которая и сегодня распространяется со многими компьютерами. 
      RCS хранит на диске наборы патчей (различий между файлами) в специальном формате, применяя которые она может воссоздавать состояние каждого файла в заданный момент времени.</p>

      <p><strong>Централизованные системы контроля версий</strong></p>
      <p>Следующая серьёзная проблема, с которой сталкиваются люди, — это необходимость взаимодействовать с другими разработчиками. Для того, чтобы разобраться с ней, были разработаны централизованные 
      системы контроля версий (ЦСКВ). Такие системы, как CVS, Subversion и Perforce, используют единственный сервер, содержащий все версии файлов, и некоторое количество клиентов, 
      которые получают файлы из этого централизованного хранилища. Применение ЦСКВ являлось стандартом на протяжении многих лет.</p>
      <p>Такой подход имеет множество преимуществ, особенно перед локальными СКВ. Например, все разработчики проекта в определённой степени знают, чем занимается каждый из них. 
      Администраторы имеют полный контроль над тем, кто и что может делать, и гораздо проще администрировать ЦСКВ, чем оперировать локальными базами данных на каждом клиенте.</p>
      <p><strong>Распределённые системы контроля версий</strong></p>

      <p>Здесь в игру вступают распределённые системы контроля версий (РСКВ). В РСКВ (таких как Git) клиенты не просто скачивают снимок всех файлов 
      (состояние файлов на определённый момент времени) — они полностью копируют репозиторий.</p>
      <p>В этом случае, если один из серверов, через который р выделения коротких цитат, браузерами заключается в кавычки.</p>
    <p><i>Элемент cite</i> - Применяется разработчиками, если обмен данными умрёт, любой клиентский репозиторий может быть скопирован на другой сервер для продолжения работы. 
      <p>Каждая копия репозитория является полным бэкапом всех данных.</p>

      <p>Более того, многие РСКВ могут одновременно взаимодействовать с несколькими удалёнными репозиториями, благодаря этому вы можете работать с различными группами людей, 
        применяя различные подходы единовременно в рамках одного проекта.</p> 
      <p>Это позволяет применять сразу несколько подходов в разработке, например, иерархические модели, что совершенно невозможно в централизованных системах.</p>

      <p><strong>GitHub</strong>  — веб-сервис, который основан на системе Git, это такая социальная сеть для разработчиков, которая помогает 
      удобно вести коллективную разработку IT-проектов, здесь можно публиковать и редактировать свой код, комментировать чужие наработки, следить за новостями других 
      пользователей.</p>

      <p>Именно в GitHub работаем мы, команда Академии, и студенты интенсивов. Для начала определим, что такое репозиторий, это рабочая директория с вашим 
      проектом. По сути, это та же папка с HTML, CSS, JavaScript и прочими файлами, что хранится у вас на компьютере, но находится на сервере GitHub.</p>
       <p>Поэтому вы можете работать с проектом удалённо на любой машине, не переживая, что какие-то из ваших файлов потеряются — все данные будут в репозитории при условии, что вы их туда 
      отправите. </p>

      <p>Если над проектом трудится команда разработчиков, как правило, создаётся общий репозиторий, в котором находится рабочая версия проекта (назовём его мастер-репозиторий), 
      при этом каждый пользователь клонирует себе в профильоригинальный репозиторий и работает именно с копией, такая копия называется форком. 

      <p>Форк — ваша персональная версия мастер-репозитория, в нём вы можете пробовать разные решения, менять код и не бояться что-то сломать в основной версии проекта.</p>
      <p>Работу над проектом принято вести в ветках, в каждом репозитории есть как минимум одна ветка. </p>

      <p>Это основная ветка, которую создаёт сам Git , она называется <ins>master</ins>, обычно в ней находится стабильная версия программы без ошибок.</p>
      <p>Если вы хотите исправить баг, добавить новую функциональность в проект, попробовать какую-то технологию, но не хотите сломать код в основной ветке, 
      вы ответвляетесь из master и трудитесь в своей новой ветке, здесь вы можете реализовывать свои идеи, не переживая, что рабочий код сломается, каждая ветка — что-то вроде второстепенной 
      дороги, которая затем снова соединяется с основной.</p>

      <p>Создадим новую ветку, открываем терминал, вводим команду git branch ,она показывает список веток, с которыми мы работаем в проекте, и выделяет текущую, 
      если мы находимся в master создаём новую ветку: git checkout -b имя-новой-ветки, если текущая ветка не master, сначала переключимся в основную ветку: git checkout master. </p>

      <p>Мы делаем это, чтобы новаяветка содержала свежую, на момент создания, рабочую версию проекта, эта команда позволяет переключаться между существующими ветками в проекте, после git checkout 
      надо указать название нужной ветки, если вы ошиблись в названии, например, допустили опечатку, вы можете изменить название ветки с помощью команды: git branch -m старое-имя-ветки 
      новое-имя-ветки, после того как вы создали ветку, поработали в ней у себя локально — нужно сохранить результат, чтобы он не пропал и в итоге оказался в репозитории.</p> 

      <p>Если вы хотите сохранить изменения не во всех файлах, для начала можно ввести команду git status, она покажет текущее состояние в вашей ветке, а именно список с названиями изменённых файлов, 
      если они есть, и укажет на те, которые ожидают записи и сохранения (обычно они выделены красным цветом), перед тем, как зафиксировать изменения отдельных файлов, нужно добавить файлы в набор 
      этих изменений, воспользуйтесь командой git add имя-файла, если название очень длинное, вы можете начать его писать, затем нажать Tab и консоль сама предложит вам продолжение пути к файлу. <p>

      <p>Если вы хотите сохранить все изменения разом, вводите git add A. Теперь мы можем сделать коммит, то есть зафиксировать все сохранённые изменения и дать им название.<p>
      Это делается с помощью команды git commit -m "ваше сообщение", текст сообщения должен быть лаконичным и в то же время сообщать о том, что делает коммит (внесённые изменения).</p>
    <p>Например, «добавляет имя наставника в Readme», «вводит функцию сортировки изображений», «правит ошибку в поиске городов на карте», сохранения зафиксированы, Они теперь в репозитории и видны 
      коллегам? Пока нет, те изменения, которые мы внесли и сохранили, пока локальны, их нужно послать на <ins>GitHub</ins>.</p>
    <p>Чтобы отправить свои изменения (коммиты) в репозиторий на GitHub, введите команду git push origin название-текущей-ветки, где origin означает репозиторий, который был склонирован на компьютер, 
      то есть ваш форк. Теперь заходим на страницу нашего форка и создаём пулреквест, чтобы слить свой код с данными в мастер-репозитории. <p>

    <p>Что такое <strong>пулреквест</strong>? Это предложение изменить код в репозитории, любое предложение можно принять или отвергнуть.</p>
    <p>Так же и с пулреквестом. После его создания, он должен получить ревью и одобрение так называемого коллаборатора — пользователя GitHub, 
     который имеет права администратора в мастер-репозитории.<p>

      <p>Им может быть ваш коллега-разработчик, техлид, наставник, если к вашему коду нет вопросов, пулреквест принимается и изменения из вашей ветки попадают в master главного репозитория.</p>
    <p>Если в код нужно внести изменения, пулреквест отклоняется, и вам нужно снова пройти по цепочке локальные изменения — сохранение — коммит — пуш, только пулреквест заново делать не нужно.</p>
    <p>Если вы продолжаете вести работу в той же ветке и пулреквест ещё не принят, все ваши изменения автоматически добавятся в пулреквест, созданный из этой ветки после команды git push origin 
      название-текущей-ветки, вы исправили код, наставник или техлид одобрил ваши правки и принял пулреквест.</p>

      <p>Теперь код в мастер-репозитории обновился, а в вашем форке нет, вы ведь не обновляли свою версию репозитория с тех пор, как клонировали её себе на компьютер. Приведём форк в актуальное 
      состояние. В локальном репозитории вводим команду git checkout master, переходим в master, теперь забираем (подтягиваем) изменения из ветки master мастер-репозитория git pull academy master.</p>

      <p>Academy здесь — сокращённое название мастер-репозитория, такое имя используется в проектах студентов Академии, вы можете выбрать любое другое название.</p>
    </p>Если консоль выдаёт ошибку и говорит, что не знает директории с таким именем, нужно добавить ссылку на этот 
      репозиторий: <ins>remote add academy git@github.com:your-repo.git</ins>, вместо academy указывайте своё название и оно закрепится 
      за этим репозиторием, теперь отправьте изменения уже из своей ветки master в ваш форк на GitHub с помощью команды </ins>git push origin master</ins>.</p>


      <p>С помощью команды «checkout» можно выписать уже существующую ветку с github: $ git checkout --track origin/production</p>
      <p>Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла feature.txt, потому что мы переключились обратно на ветку master, в которой такого файла не существует.</p>
      <p>Чтобы он появился, нужно воспользоваться merge для объединения веток (применения изменений из ветки amazing_new_feature к основной версии проекта). $ git merge amazing_new_feature</p>

      <p>Команда git add может быть использована для добавления файлов в индекс. К примеру, следующая команда добавит файл под названием temp.txt присутствующий в локальном каталоге в 
      индекс: git add temp.txt</p>


      <p>Команда git commit используется для коммита изменений в файлах проекта. Обратите внимание, что коммиты не сразу попадают на удаленный репозиторий.</p>
      <p>Применение: git commit –m “Сообщение идущее вместе с коммитом”.</p>

      <p>Команда pull используется для объединения изменений, присутствующих в удаленном репозитории, в локальный рабочий каталог.</p>
      
      <p>git push еще одна из часто используемых git команд. Позволяет поместить изменения в главную ветку удаленного хранилища связанного с рабочим каталогом.</p>
      <p>Например: git push origin master</p>

      <p><strong>Ветвления и слияния</strong></p>

      <p>Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в вашем проекте. Ваша работа построена так:</p>
      <p>Вы работаете над сайтом.</p>

      <p>Вы создаете ветку для новой статьи, которую вы пишете.</p>

      <p>Вы работаете в этой ветке.</p>

      <p>В этот момент вы получаете сообщение, что обнаружена критическая ошибка, требующая скорейшего исправления. Ваши действия:</p>

      <p>Переключиться на основную ветку.</p>

      <p>Создать ветку для добавления исправления.</p>

      <p>После тестирования слить ветку содержащую исправление с основной веткой.</p>

      <p>Переключиться назад в ту ветку, где вы пишете статью и продолжить работать.</p>

      <p><strong>Основы ветвления</strong></p>
      <p>Предположим, вы работаете над проектом и уже имеете несколько коммитов.</p>

      <p>Вы решаете, что теперь вы будете заниматься проблемой #53 из вашей системы отслеживания ошибок. Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду git checkout с 
      параметром -b:</p>

      <p>$ git checkout -b iss53</p>
     <p>Switched to a new branch "iss53"</p>
     <p>Это тоже самое что и:
     <p>$ git branch iss53</p>
     <p>$ git checkout iss53</p>
     <p>Вы работаете над своим сайтом и делаете коммиты. Это приводит к тому, что ветка iss53 движется вперед, так как вы переключились на нее ранее (HEAD указывает на нее).</p>
     <p>$ vim index.html</p>
     <p>$ git commit -a -m 'added a new footer [issue 53]'</p>

     <p>Тут вы получаете сообщение об обнаружении уязвимости на вашем сайте, которую нужно немедленно устранить. Благодаря Git, не требуется размещать это исправление вместе с тем, 
      <p>что вы сделали в iss53. Вам даже не придется прилагать усилий, чтобы откатить все эти изменения для начала работы над исправлением. Все, что вам нужно — переключиться на ветку master.</p>
      <p>Но перед тем как сделать это — имейте в виду, что если ваш рабочий каталог либо область подготовленных файлов содержат изменения, не попавшие в коммит и конфликтующие с веткой, на которую 
      вы хотите переключиться, то Git не позволит вам переключить ветки. Лучше всего переключаться из чистого рабочего состояния проекта, есть способы обойти это (спрятать (stash) или исправить (amend) 
      коммиты), но об этом мы поговорим позже в главе Прибережение и очистка, теперь предположим, что вы зафиксировали все свои изменения и можете переключиться на ветку master:</p>

     <p>$ git checkout master</p>
    <p>Switched to branch 'master'</p>

     <p>С этого момента ваш рабочий каталог имеет точно такой же вид, какой был перед началом работы над проблемой #53, и вы можете сосредоточиться на работе над исправлением.</p>
      <p>Важно запомнить: когда вы переключаете ветки, Git возвращает состояние рабочего каталога к тому виду, какой он имел в момент последнего коммита в эту ветку. </p>
      <p>Он добавляет, удаляет и изменяет файлы автоматически, чтобы состояние рабочего каталога соответствовало тому, когда был сделан последний коммит.</p>
    <p>Теперь вы можете перейти к написанию исправления. Давайте создадим новую ветку для исправления, в которой будем работать, пока не закончим исправление.</p>

     <p>$ git checkout -b hotfix</p>
     <p>Switched to a new branch 'hotfix'</p>
     <p>$ vim index.html</p>
     <p>$ git commit -a -m 'fixed the broken email address'</p>
     <p>[hotfix 1fb7853] fixed the broken email address</p>
     <p>1 file changed, 2 insertions(+)</p>
     <p>Вы можете прогнать тесты, чтобы убедиться, что ваше исправление делает именно то, что нужно. И если это так — выполнить слияние ветки hotfix с веткой master для включения изменений в продукт. 
     <p>Это делается командой git merge:</p>
     <p>$ git checkout master</p>
     <p>$ git merge hotfix</p>
     <p>Updating f42c576..3a0874c</p>
     <p>Fast-forward</p>
     <p>index.html | 2 ++</p>
     <p>1 file changed, 2 insertions(+)</p>

      <p>Заметили фразу “fast-forward” в этом слиянии? Git просто переместил указатель ветки вперед, потому что коммит C4, на который указывает слитая ветка hotfix, был прямым потомком коммита C2, 
      на котором вы находились до этого, другими словами, если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, 
      так как нет расхождений в изменениях, это называется “fast-forward”.</p>

     <p>Теперь ваши изменения включены в коммит, на который указывает ветка master, и исправление можно внедрять.
      После внедрения вашего архиважного исправления вы готовы вернуться к работе над тем, что были вынуждены отложить. Но сначала нужно удалить ветку hotfix, потому что она больше не нужна 
      — ветка master указывает на то же самое место. Для удаления ветки выполните команду git branch с параметром -d:</p>

     <p>$ git branch -d hotfix</p>

     <p>Deleted branch hotfix (3a0874c).</p>

     <p>Теперь вы можете переключиться обратно на ветку iss53 и продолжить работу над проблемой #53:</p>

     <p>$ git checkout iss53</p>

     <p>Switched to branch "iss53"</p>

     <p>$ vim index.html</p>

     <p>$ git commit -a -m 'finished the new footer [issue 53]'</p>

     <p>[iss53 ad82d7a] finished the new footer [issue 53]</p>

     <p>1 file changed, 1 insertion(+)</p>

     <p><strong>Основы слияния</strong></p>

     <p>Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку master. Для этого нужно выполнить слияние ветки iss53 точно так же, как вы делали это с веткой hotfix ранее. 
     <p>Все что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду git merge:</p>

     <p>$ git checkout master</p>

     <p>Switched to branch 'master'</p>

     <p>$ git merge iss53</p>

     <p>Merge made by the 'recursive' strategy.</p>

     <p>index.html |    1 +</p>

     <p>1 file changed, 1 insertion(+)</p>

     <p>Результат этой операции отличается от результата слияния ветки hotfix. В данном случае процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы находимся, не 
      является прямым родителем ветки, с которой мы выполняем слияние, Git придётся немного потрудиться.</p>

     <p>В этом случае Git выполняет простое трёхстороннее слияние используя последние коммиты объединяемых веток и общего для них родительского коммита.</p>

     <p>Вместо того, чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый результирующий снимок трёхстороннего слияния, а затем автоматически делает коммит. Этот особый коммит называют
      коммитом слияния, так как у него более одного предка.</p>

     <p>Теперь, когда изменения слиты, ветка iss53 больше не нужна, вы можете закрыть задачу в системе отслеживания ошибок и удалить ветку: $ git branch -d iss53</p>

     <p><strong>Node.js</strong>- это программная платформа, которая предоставляет среду для выполнения кода JavaScript на стороне сервера. Node.js относится к событийно-ориентированным системам
      и использует модель выполнения операций ввода-вывода (I/O) таким образом, что основной процесс никогда не блокируется, за исключением редких случаев, а отсутствие единого блокируемого потока 
      выполнения позволяет создавать эффективные, высокопроизводительные и легко масштабируемые серверные приложения. Установка Node.js и  NPM довольно проста, все делается с помощью установочного
      пакета, который можно загрузить с веб-сайта Node.js. </p>

      <p>Загрузите установщик с официального сайта Node.js Запустите программу установки.</p>

      <p>Следуйте инструкциям в программе установки Для того чтобы проверить правильно ли прошла установка необходимо: Открыть консоль для проверки установки Node.js выполнить команду node -v для 
      проверки установки пакетного менеджера NPM выполнить команду npm -v Если в ответ вы получили номера версий, как показано на изображении, то установка выполнена правильно, 
      теперь попробуем выполнить простую операцию с помощью Node.js. В папке для обучения создайте файл 
      index.js Добавте в него вывод произвольной строки на консоль. </p>

      <p>В консоли перейдите в папку для обучения и выполните команду node index.js Если после этого в консоли 
      отобразилась нужная строка, значит вы все сделали верно. Установка модулей – одна из самых важных вещей, которую вы должны научиться делать, начиная работу с менеджером 
      пакетов Node, вот команда для установки модуля в текущий каталог: $ npm install  $ npm i</p>

      <p><strong>npm</strong> – это менеджер пакетов, который входит в состав Node.js. В течение многих лет Node широко использовался разработчиками JavaScript для обмена 
      инструментами, установки различных модулей и управления их зависимостями, чтобы узнать информацию об установке можно выполнить команду npm config list, на консоль 
      будет выведена нужная нам информация, для получения значения конкретной опции используется команда npm config getТак выполнив команду npm config get prefix мы 
      получим путь установки глобальных пакетов, кроме получения опций, мы также можем их изменять.</p> 

      <p>Для этого мы воспользуемся командой npm config set, чтобы заменить текущий путь установки глобальных пакетов, напраимер на папку node_modules_global ву домашней директории, 
        необходимо вполнить команду npm config set prefix=$HOME/.node_modules_global.</p>

      <p>С помощью npm config get можно проверить, что путь поменялся, начальный тег показывает, где начинается элемент, конечный — где заканчивается. 
      <p>Закрывающий тег образуется путем добавления слэша / перед именем тега: имя тега /имя тега</p>
        <p>Между начальным и закрывающим тегами находится содержимое элемента — контент, элементы, представленные одиночными тегами, не могут хранить в себе содержимого напрямую, оно прописывается 
            как значение атрибута, например, элемент  <ins>input</ins> type="button" value="Кнопка" создаст кнопку с текстом.</p>

      <p>Структура HTML-документа Начальный тег показывает, где начинается элемент, конечный — где заканчивается. 
      <p>Страница сайта - это обычный текстовый файл с расширением .html. Внутри этого файла и хранится текст HTML страницы вместе с тегами. Этот файл обязательно должен иметь следующие теги: 
        тег <ins>html</ins>, который должен содержать в себе текст всего сайта (все, что написано вне этого тега, браузером будет проигнорировано), а внутри него должны быть еще два тега: 
        тег <ins>head</ins> для служебного содержимого страницы и тег body - для основного текста, который и виден на экране браузера.

      <p>В служебное содержимое, которое располагается внутри тега <ins>head</ins>, входит много различных вещей, но пока нам нужны только две из них. Это тег <ins>title</ins>, 
          задающий название страницы, которое будет видно во вкладке браузера, и тег <ins>meta</ins>, который задает кодировку страницы (она ставится в атрибуте charset и 
          обычно имеет значение utf-8, подробнее об этом в видео, которое будет ниже на пару абзацев).</p>
        
        <p>Кроме того, перед тегом <html> обычно пишется конструкция doctype, которая указывает версию языка HTML, на которой сделан сайт. Актуальная сейчас версия языка имеет номер 
          пять и доктайп для нее должен выглядеть так - <ins>!DOCTYPE html.</ins></p>

          <p><strong>блочные и строчные элементы</strong></p>
          <p>Выделяют две основные категории HTML-элементов, которые соответствуют типам их содержимого и поведению в структуре веб-страницы — блочные и строчные элементы.</p>
           помощью блочных элементов можно создавать структуру веб-страницы, строчные элементы используются для форматирования текстовых фрагментов (за исключением элементов <area> и <img>).

          <p>Разделение элементов на блочные и строчные используется в спецификации HTML до версии 4.01. В HTML5 эти понятия заменены более сложным набором категорий контента, с
          огласно которым каждый HTML-элемент должен следовать правилам, определяющим, какой контент для него допустим.</p>
          Каждый блок в дереве представляет соответствующий элемент или псевдоэлемент, а текст (буквы, цифры, пробелы), 
          находящийся между открывающим и закрывающим тегами, представляет содержимое текстовых узлов.
          Чтобы создать дерево блоков, CSS сначала использует каскадирование и наследование, позволяющие назначить вычисленное значение для каждого css-свойства каждому элементу и текстовому узлу в исходном дереве.

            Затем для каждого элемента CSS генерирует ноль или более блоков в соответствии со значением свойства display этого элемента. Как правило, элемент генерирует один основной блок, который представляет самого 
             себя и содержит свое содержимое. Некоторые значение свойства display, например, display: list-item;, генерируют блок основного блока и блок дочернего маркера. Другие, например, display: none;, приводят к тому, что элемент и/или его потомки вообще не генерируют блоки.
   
             <p><strong>Положение блоков на странице определяется следующими факторами:</strong></p>

           <ol>

             <li>размером элемента (с учётом того, заданы они явно или нет)</li>
            <li>типом элемента (строчный или блочный)</li>
          <li>схемой позиционирования (нормальный поток, позиционированные или плавающие элементы)</li>
        <li>отношениями между элементами в DOM (родительский — дочерний элемент)</li>
      <li>внутренними размерами содержащихся изображений</li>
    <li>внешней информацией (например, размеры окна браузера).</li>

           </ol>

          <p>Блочные элементы — элементы высшего уровня, которые форматируются визуально как блоки, располагаясь на странице в окне браузера вертикально. Значения свойства display, такие как block, 
           list-item и table делают элементы блочными. Блочные элементы генерируют основной блок, который содержит только блок элемента.</p>
          <p>Элементы со значением display: list-item генерируют дополнительные блоки для маркеров, которые позиционируются относительно основного блока.</p>
          <p>Блочные элементы могут размещаться непосредственно внутри элемента body,они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину веб-страницы или блока-родителя.</p>
      <p>Блочные элементы могут содержать как строчные, так и блочные элементы, но не оба типа элементов сразу, при необходимости, строки текста, принадлежащие блочному контейнеру, могут быть обёрнуты анонимными контейнерами, которые будут 
        вести себя внутри блока как элементы со значением display: block;, а строчные элементы обёрнуты элементом </p> 
    <p>Блочные элементы могут содержаться только в пределах блочных элементов.</p>
      <p>Элемент p относится к блочным элементам, но он не должен содержать внутри себя другой элемент p, а также любой другой блочный элемент.</p>
     <p>Между начальным и закрывающим тегами находится содержимое элемента — контент, язык HTML следует правилам, которые содержатся в файле объявления типа документа (Document Type Definition, или DTD).</p>
    <p>DTD представляет собой XML-документ, определяющий, какие теги, атрибуты и их значения действительны для конкретного 
      типа HTML, для каждой версии HTML есть свой DTD, DOCTYPE отвечает за корректное отображение веб-страницы браузером,dOCTYPE определяет не только версию HTML 
      (например, html), но и соответствующий DTD-файл в Интернете.</p> 

      <p>Внутри этого элемента задаются стили, которые используются на странице, для задания стилей в HTML-документе используется язык CSS, элементы на странице может быть несколько, элемент может содержать код форматирования как самих элементов веб-страницы, так и веб-страницы 
      целиком, элемент внутри этого элемента задаются стили, которые используются на странице, для задания стилей в HTML -документе используется язык CSS, элементов на странице может быть несколько, может содержать код форматирования как самих элементов веб-страницы, так и веб-страницы целиком.</p>  
     <p>Задать стили для документа можно также при помощи другого способа — записать их в отдельный файл с расширением .css, например, style.css. hTML-списки используются 
      для группировки связанных между собой фрагментов информации.</p>
      
      <p>Существует три вида списков:</p>
      <p>маркированный список — ul  каждый элемент списка li отмечается маркером</p>
                    <p>нумерованный список — ol  каждый элемент списка li отмечается цифрой</p>
                            <p>список определений — dl состоит из пар термин dt — dd определение.</p>         
                                <p>В качестве маркера элемента списка выступает метка, например, закрашенный кружок</p>

        <p>ML-таблицы упорядочивают и выводят на экран данные с помощью строк или столбцов, таблицы состоят из ячеек, образующихся при пересечении строк и столбцов, ячейки таблиц могут содержать любые HTML-элементы, такие как заголовки, списки, текст, изображения, элементы форм, а также другие таблицы. 
          каждой таблице можно добавить связанный с ней заголовок, расположив его перед таблицей или после неё, таблицы больше не используются для вёрстки веб-страниц и компоновки отдельных элементов, потому что такой приём не обеспечивает гибкость структуры и адаптивность сайта, существенно увеличивая HTML-разметку.</p>
        <p>Таблица создаётся при помощи элемента  table /table</p>
        <p>является контейнером для элементов таблицы и все элементы должны находиться внутри него.</p>
        <p>Например, с помощью данной разметки можно создать таблицу, состоящую из двух столбцов и двух строк:</p>
                     <p>table</p>
                           <p>tr</p>
                              <p>th текст заголовка /th</p>
                                 <p>th текст заголовка /th</p>
                                    <p>/tr</p>
                                      <p>!--ряд с ячейками заголовков--</p>
                                          <p>tr</p>
                                             <p>td>данные /td</p>
                                               <p>td данные /td</p>
                                                    <p>/tr</p>
                                                      <p>!--ряд с ячейками тела таблицы--</p>
                                                         <p>/table</p>
      
        <p><strong>Якорь</strong> - это закладка с уникальным именем, которая размещена в html документе в определенном месте и служит для быстрого перехода к ней по ссылке.</p>
        <p>Частенько используют ссылки-Якоря, для бизнес-сайтов (одностаничники) или же в самом начале статьи, для быстрого перехода до нужного раздела (так как в Википедии),
        чтобы создать якорь на веб-странице, к тегу a пропишите атрибут «name», где в значение указываете уникальное название.</p>
        <p>Вот так выглядит макет якоря в HTML:a name="имя_якоря" текст или заголовок для тега a закрывающий тег /a- обязателен.</p>
      <p>Cсылку можно также сделать на закладку, находящуюся в другой веб-странице и даже другом сайте, для этого в атрибуте href тега a
        надо указать адрес документа и в конце добавить символ решетки # и имя закладки a href="text.html#bottom" Перейти к нижней части текста /a</p>

        

      <p>HTML-атрибуты сообщают браузеру, каким образом должен отображаться тот или иной элемент страницы, атрибуты позволяют сделать более разнообразными внешний вид информации.</p>
    <p>Значение атрибута заключается в кавычки "". Названия и значения атрибутов не чувствительны к регистру, но, тем не менее, рекомендуется набирать их в нижнем регистре.</p>
  <p>Глобальные атрибуты, приведенные в таблице ниже, могут быть использованы для любого HTML-элемента, хотя некоторые из них могут не оказывать на элементы никакого влияния.</p>
<p>Блочные элементы являются основой, которая используется для верстки веб-страниц, такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину
    страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого.</p>
  <p>Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом.</p>
<p>Блочный элемент может содержать в себе другие блочные и строчные элементы.</p>
<p>Примеры блочных элементов: div, p, ul, ol, h1 и т. д.</p>

            <p><strong>Строчные элементы</strong></p>
          <p>В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент.</p>
        <p>Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, 
             что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.</p>
            <p>Примеры строчных элементов: a, span, strong, em, img и т. д.</p>
          <p>При помощи крайне полезного свойства display в CSS можно заставить блочный элемент выглядеть как строчный и наоборот. Чтобы блочный элемент вел себя как inline-элемент (т. е. не переводился на новую строку), для него необходимо записать правило:</p>
        <p>display: inline</p> Если же необходимо отобразить строчный элемент как block-элемент (чтобы до и после элемента происходил перенос строки), запишите следующее:</p>
      <p>display: block;</p>
             

        <p><strong>ссылки</strong> - создаются с помощью элементов a, area и link, ссылки представляют собой связь между двумя ресурсами, одним из которых является текущий документ.</p>
        <p>Для создания ссылки необходимо сообщить браузеру, что является ссылкой, а также указать адрес документа, на который следует сделать ссылку.</p>
      <p>Оба действия выполняются с помощью тега a. общий синтаксис создания ссылок следующий -  <ins>a href="URL">текст ссылки /a</ins></p>
      <p>Атрибут href определяет URL (Universal Resource Locator, универсальный указатель ресурса), иными словами, адрес документа, на который следует перейти, 
      а содержимое контейнера a является ссылкой, текст, расположенный между тегами a и /a, по умолчанию становится синего цвета и подчеркивается.</p>
      <p>В данном примере ссылка вида a href="http://htmlbook.ru" Изучение HTML /a является абсолютной и ведет на главную страницу сайта htmlbook.ru.</p>
      <p><ins>Абсолютные ссылки</ins> - обычно применяются для указания документа на другом сетевом ресурсе, впрочем, допустимо делать абсолютные ссылки и внутри текущего сайта.</p>
        <p>Однако подобное практикуется нечасто, поскольку такие ссылки достаточно длинные и громоздкие, поэтому внутри сайта преимущественно используются относительные ссылки.</p>

      <p>Ссылки относительно текущего документа при создании относительных ссылок надо понимать, какое значение для атрибута href следует указывать, поскольку оно зависит от исходного расположения файлов.</p>
    <p>Рассмотрим несколько типичных вариантов:</p>

  <p>Необходимо сделать ссылку из исходного документа на ссылаемый, в таком случае код будет следующий - a href="Ссылаемый документ.html" Ссылка /a.</p>
<p>Подобное имя файла взято только для образца, на сайте в именах файлов не следует использовать русские символы с пробелами, да еще и в разном регистре.</p>

<p>Когда исходный документ хранится в одной папке, а ссылаемый в корне сайта, то перед именем файла в адресе ссылки следует поставить две точки и слэш (/), как показано ниже.</p>
<p>a href="../Ссылаемый документ.html"Ссылка /a (две точки в данном случае означают выйти из текущей папки на уровень выше).</p>
<p>Теперь исходный файл находится в двух вложенных папках, и чтобы сослаться на документ в корне сайта, требуется повторить написание предыдущего примера два раза</p>
<p>a href="../../Ссылаемый документ.html" Ссылка/a</p>
<p>Ссылки относительно корня сайта</p>
<p>Иногда можно встретить путь к файлу относительно корня сайта, он выглядит как "/Папка/Имя файла" со слэшем вначале, запись a href="/course/" Курсы /a  означает,
что ссылка ведет в папку с именем course, которая располагается в корне сайта, а в ней необходимо загрузить индексный файл,такая форма записи не работает на локальном компьютере, 
<p>а только под управлением веб-сервера.</p>
<p>Создание ссылки на адрес электронной почты делается почти также как и ссылка на веб-страницу. Только вместо URL указывается mailto:адрес электронной почты
a href="mailto:vlad@htmlbook.ru" Задавайте вопросы по электронной почте /a</p>

              <p>гиперссылки — ссылки на другие ресурсы, которые пользователь может посетить или загрузить.</p>  
                     <p>Гиперссылки создаются с помощью элемента a, внутрь помещается текст, который будет отображаться на веб-странице. 
                    Текст ссылки отображается в браузере с подчёркиванием, цвет шрифта — синий, при наведении на ссылку курсор мыши меняет вид.</p>
                  <p>Обязательным параметром элемента a является атрибут href, который задает URl-адрес веб-страницы  a href="http://site.ru">указатель ссылки /a</p>

        <p><strong>Аббревиатура W3C</strong> - (World Wide Web) обозначает сообщество единых стандартов.</p>
        <p>Еще со времен зарождения Всемирной паутины этот консорциум определил единые стандарты для всех веб-страниц с целью правильного отображения их различными браузерами.</p>
    <p>W3C-валидатор призван проверить, насколько сайт соответствует единым стандартам и, при обнаружении неточностей, указывает на них.</p>

        <p>Если игнорировать данный анализ, то может оказаться, что плохой трафик, проблемы с продвижением возникают из-за банальных неточностей кода.</p>

    <p>Бывает достаточно одной опечатки, неправильно закрытой скобки, чтобы сайт неверно прогружался в браузере. А, как известно, проблемы с загрузкой сайта или неправильным его отображением 
        приводят к тому, что пользователи быстро покидают эту веб-страницу.</p>

   <p>Поэтому использование сервисов проверки дает массу преимуществ:</p>

   <p>1. поднятие рейтинга в поисковых системах</p>
   <p>2. Проверка html-кода поможет избежать неточностей или ошибок в коде, облегчая работу СЕО сайта.</p>

   <p>Алгоритмы поисковиков настроены таким образом, что при индексации боты проверяют код гипертекста на предмет его соответствия единым стандартам.</p>
   <p>При обнаружении ошибок они попросту игнорируют страницу (или ее часть), оставляя ее непроиндексированной.</p>
   <p>Вообще вокруг темы взаимосвязи валидации сайта и его дальнейшего продвижения существует множество мифов, и мнения экспертов на этот счет разнятся.</p>
   <p>Идеально прописанный код страницы еще не является гарантом ее дальнейшего высокого рейтинга.</p>

    <p>Здесь важно увидеть и проанализировать ошибки, обнаруженные сервисами, и понять, какие из них отразятся на производительности и работоспособности веб-ресурса.</p>
   <p><ins>Валидатор HTML</ins> – это служба, которая проверяет разметку HTML и синтаксис XHTML-кода, причем проверку можно проводить тремя различными способами: путем добавления файла, фрагмента текста или адреса ресурса.</p>
   <p>Сервис дополнительно позволяет установить набор инструментов для исследования кодировки документа, его типа, Такие недочеты, как открытые теги, пропущенные кавычки, лишние пробелы и т. д., могут привести к тому, 
       что веб-страница будет выглядеть совершенно иначе, чем планировалось.</p>
   <p>Следует понимать, что служба проверяет сайт или часть текста исключительно на предмет наличия синтаксических ошибок, но не исследует семантику кода.</p>

    <p>В рамки проверки валидатора входит:</p>
    <p>1.проверка незакрытых тегов;</p>
    <p>2.анализ синтаксиса;</p>
    <p>3.наличие лишних ненужных элементов.</p>
    <p>4.CSS VALIDATOR</p>

<p>Удобный бесплатный сервис, позволяющий разработчикам и дизайнерам при анализе и правке CSS.</p>

<p>Для проверки просто вводим в строку url адрес страницы и запускаем процесс.</p>

<p>После исследования появится надпись об отсутствии ошибок либо же будут указаны недочеты при невалидном коде. Дальше уже веб-мастер отрабатывает все эти недочеты и проводит повторную проверку.</p>
<p>Последняя вкладка позволяет сразу исследовать онлайн часть набранного текста непосредственно в HTML.</p>


<p><strong>CSS</strong></p>

<p><ins>стили</ins></p>

<p>Внешняя таблица стилей представляет собой текстовый файл с расширением .css, в котором находится набор CSS-стилей элементов. Файл создаётся в редакторе кода, так же как и HTML-страница. Внутри файла могут содержатся только стили, без HTML-разметки. </p>
<p>Внешняя таблица стилей подключается к веб-странице с помощью тега link, расположенного внутри раздела head /head. Такие стили работают для всех страниц сайта.</p>

<p>К каждой веб-странице можно присоединить несколько таблиц стилей, добавляя последовательно несколько тегов link, указав в атрибуте тега media назначение данной таблицы стилей. rel="stylesheet" указывает тип ссылки (ссылка на таблицу стилей).</p>

<p>head</p>
<p>link rel="stylesheet" href="css/style.css"</p>
<p>link rel="stylesheet" href="css/assets.css" media="all"</p>
<p>/head</p>

<p>Внутренние стили встраиваются в раздел head /head HTML-документа и определяются внутри тега style /style. Внутренние стили имеют приоритет над внешними, но уступают встроенным стилям (заданным через атрибут style).</p>

<p>Правило @import позволяет загружать внешние таблицы стилей. Чтобы директива @import работала, она должна располагаться в таблице стилей (внешней или внутренней) перед всеми остальными правилами:</p>

<p>Классы задаются с помощью атрибута class, в котором мы пишем имя класса. Их преимущество в том, что один и тот же класс может быть у многих элементов на странице.</p>

<p>То есть, если элементы должны вести себя одинаково - мы даем им один и тот же класс.</p>

<p>Как обратиться к элементам с определенным классом в CSS: пусть мы задали нужным нам элементам класс с именем test, тогда в CSS ко всем элементам с этим классом мы можем обратиться следующим образом</p>

<p>.test - вначале символ "точка" и потом имя класса из атрибута class.</p>
<p>.test {<p>
	<p>color: red;</p>
<p>}</p>

<p><strong>Идентификатор</strong> - (называемый также «ID селектор») определяет уникальное имя элемента, которое используется для изменения его стиля и обращения к нему через скрипты.</p>

<p>Синтаксис применения идентификатора следующий:</p>

<p>#Имя идентификатора { свойство1: значение; свойство2: значение; ... }</p>
<p>При описании идентификатора вначале указывается символ решётки (#), затем идет имя идентификатора. Оно должно начинаться с латинского символа и может содержать в себе символ дефиса (-) 
    и подчеркивания (_). Использование русских букв в именах идентификатора недопустимо.</p>

<p>В отличие от классов идентификаторы должны быть уникальны, иными словами, встречаться в коде документа только один раз, как и при использовании классов, 
идентификаторы можно применять к конкретному тегу. Синтаксис при этом будет следующий:</p>
<p>Тег #Имя идентификатора { свойство1: значение; свойство2: значение; ... }</p>
<p><strong>селекторы</strong>
<p>При создании веб-страницы часто приходится вкладывать одни теги внутрь других, чтобы стили для этих тегов использовались корректно, помогут селекторы, которые работают только в определённом контексте.</p>
<p>Например, задать стиль для тега b только когда он располагается внутри контейнера p, таким образом можно одновременно установить стиль для отдельного тега, а также для тега, который находится внутри другого.</p>
<p>Контекстный селектор состоит из простых селекторов разделенных пробелом, так, для селектора тега синтаксис будет следующий - Тег1 Тег2 { ... }</p>
<p><strong>Псевдоклассы</strong> — это классы, фактически не прикрепленные к HTML-тегам. Они позволяют применить CSS-правила к элементам при совершении события или подчиняющимся определенному правилу.</p>

<p><strong>Псевдоклассы</strong> характеризуют элементы со следующими свойствами:</p>

<ol>
<li>link — не посещенная ссылка;</li>
<li>visited — посещенная ссылка;</li>
<li>hover — любой элемент, по которому проводят курсором мыши;</li>
<li>focus — интерактивный элемент, к которому перешли с помощью клавиатуры или активировали посредством мыши;</li>
<li>active — элемент, который был активизирован пользователем;</li>
<li>valid — поля формы, содержимое которых прошло проверку в браузере на соответствие указанному типу данных;</li>
<li>invalid — поля формы, содержимое которых не соответствует указанному типу данных;</li>
<li>enabled — все активные поля форм;</li>
<li>disabled — заблокированные поля форм, т.е., находящиеся в неактивном состоянии;</li>
<li>in-range — поля формы, значения которых находятся в заданном диапазоне;</li>
<li>out-of-range — поля формы, значения которых не входят в установленный диапазон;</li>
<li>lang() — элементы с текстом на указанном языке;</li>
<li>not(селектор) — элементы, которые не содержат указанный селектор — класс, идентификатор, название или тип поля формы — :not([type="submit"]);</li>
<li>target — элемент с символом #, на который ссылаются в документе;</li>
<li>checked — выделенные (выбранные ользователем) элементы формы.</li>
</ol>
<p><ins>Селектор структурных псевдоклассов</ins></p>                                  
<p><strong>Псевдоэлементы</strong> позволяют задать стиль элементов не определённых в дереве элементов документа, а также генерировать содержимое, которого нет в исходном коде текста.</p>
<p>Синтаксис использования псевдоэлементов следующий.</p>
    <p>Селектор: Псевдоэлемент { Описание правил стиля }Вначале следует имя селектора, затем пишется двоеточие, после которого идёт имя псевдоэлемента, каждый псевдоэлемент может 
применяться только к одному селектору, если требуется установить сразу несколько псевдоэлементов для одного селектора, правила стиля должны добавляться к ним по отдельности, как показано ниже:</p>
<p> .foo:first-letter { color: red }</p>
<p>.foo:first-line {font-style: italic}</p>

<p><strong>псевдоэлементы</strong></p>

</p>Псевдоэлементы позволяют задать стиль элементов не определённых в дереве элементов документа, а также генерировать содержимое, которого нет в исходном коде текста.<p>
</p>Синтаксис использования псевдоэлементов следующий. Селектор:Псевдоэлемент { Описание правил стиля }<p>

<p><ins>Далее перечислены все псевдоэлементы, их описание и свойства:</ins></p>
<ol>
<li><i>Псевдоэлемент after</i> - Применяется для вставки назначенного контента после содержимого элемента, этот псевдоэлемент работает совместно со стилевым свойством content, которое определяет содержимое для вставки. P.new:after {content: " - пример"; /* Добавляем после текста абзаца */}</li>                                                                   
<li><i>Псевдоэлемент before</i> - По своему действию :before аналогичен псевдоэлементу :after, но вставляет контент до содержимого элемента. </li>
<li><i>Псевдоэлемент first-letter</i> -  Определяет стиль первого символа в тексте элемента, к которому добавляется, это позволяет создавать в тексте буквицу и выступающий инициал.</li>
<li><i>Псевдоэлемент first-line</i> - Определяет стиль первой строки блочного текста, длина этой строки зависит от многих факторов, таких как используемый шрифт, размер окна браузера, ширина блока, языка и т.д. псевдоэлемент first-line могут применяться не все стилевые свойства, 
    допустимо использовать свойства, относящиеся к шрифту, изменению цвет текста и фона, а также: clear, line-height, lette.</li> 
</ol>
      </div> 


<footer> 
<p style="text-align: center;">Роман Кривак</p>
<p style="text-align: center;"><a href="https://github.com/Roman151-hub/proekt1">проект на github</a></p>
<p style="text-align: center;"><a href="https://dribbble.com/shots/14902214/attachments/6615689?mode=media ">дизайн сайта</a></p>
</footer>
</body>
</html>